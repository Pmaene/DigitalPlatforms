dp adder_dp (in sel : ns(1); in a, b : ns(1026); out s: ns(1027)) {
    sig b_eff : ns(1026);

    always {
        b_eff = sel == 1 ? (~b + 1) : b;
	    s = a + b_eff;
    }
}

dp decoder_dp(in ins : ns(8); in din : ns(1027); out dout: ns(1024); out address: ns(8); out wr : ns(1); out done : ns(8)) {
    reg data    : ns(1024);
	reg i       : ns(8);
    reg ins_reg : ns(8);
    reg din_reg : ns(1027);

    sfg decode {
        ins_reg = ins;
        din_reg = din;
    }

    sfg push { 
	    wr = 0;
		address = i;
		i = i+1;
		dout = 0;
		data = data << 8 | din;
		$display($cycle, " fetching at address ", i, " getting ", din," having ", data);
    }
   
    sfg pull    { 
		wr = 0;
		address = 0;
		i = 0;
		dout = 0;
		$display($cycle, " i is reset ");
	}
}

fsm decoder(decoder_dp) {
    initial init;
    state do, done, get_data;

    @init       (decode, pull) -> do;
    @do         if (ins_reg == 1) then
                    (push, decode) -> get_data;
                else
                    (decode, pull) -> do;
    @done       if (ins_reg == 0) then
                    (decode, pull) -> do;
                else
                    (decode, pull) -> done;
	@get_data   if (i > 3) then
                    (decode, pull) -> done;
				else
                    (push) -> get_data;
}

dp montgomery_dp (in a, b, m : ns(1024); out r : ns(1027))
{
    reg counter : ns(11);
    reg r_reg   : ns(1027);
    reg a_reg   : ns(1024);

    sig r_tmp   : ns(1027);
    sig sel     : ns(1);
    sig x       : ns(1026);
    sig y       : ns(1026);

    use adder_dp(sel, x, y, r_tmp);

    sfg init {
	    counter = 0;
	    r = 0;
	    r_reg = 0;
        
        x = 0;
        y = 0;
        sel = 0;

        a_reg = a;
    }

    sfg loop {
    }

    sfg count_inc {
	    counter = counter + 1;
        a_reg = a_reg >> 1;
    }

    sfg count_rst {
	    counter = 0;
    }

    sfg sum {
        x = r_reg;
        y = a_reg[0] == 0 ? 0 : b;
        sel = 0;
        r_reg = r_tmp;
    }

    sfg just_divide {
        sel = 0;
        x = 0;
        y = 0;
	    r_reg = r_reg >> 1;
    }

    sfg sum_and_divide {
        x = r_reg;
        y = b;
        sel = 0;volatile xdata __at 0x4000 unsigned char SHARED[4];
        r_reg = r_tmp >> 1;
    }

    sfg sum_m_and_divide {
        x = r_reg;
        y = m;
        sel = 0;
        r_reg = r_tmp >> 1;
    }

    sfg equal_to_zero {
        sel = 0;
        x = 0;
        y = 0;
	    r_reg = r_reg >> 1;
    }

    sfg not_equal_to_zero {
        sel = 0;
        x = r_reg;
        y = m;
	    r_reg = r_tmp >> 1;
    }

    sfg overflow_check {
        sel = 1;
        x = r_reg;
        y = r_reg >= m ? m : 0;
        r_reg = r_tmp;
    }

    sfg stop {
        sel = 0;
        x = 0;
        y = 0;
        r = r_reg;

        $display("A: ", $dec, a, " B: ", $dec, b, " M: ", $dec, m, " R: ", $dec, r);
	    $finish;
    }

    sfg reset_r {
        r = 0;
    }
}

fsm montgomery (montgomery_dp)
{
    initial init;
    state loop, stop, if_else;

    @init	    (init) -> loop;
    @loop	    if (counter >= 1024) then
			        (count_rst, overflow_check, reset_r) -> stop;
		        else if (r_reg[0] == 0 & a_reg[0] == 0) then
                    (just_divide, count_inc, reset_r) -> loop;
                else if (r_reg[0] == 0 & a_reg[0] == 1 & b[0] == 0) then
                    (sum_and_divide, count_inc, reset_r) -> loop;
                else if (r_reg[0] == 1 & a_reg[0] == 1 & b[0] == 1) then
                    (sum_and_divide, count_inc, reset_r) -> loop;
                else if (r_reg[0] == 1 & a_reg[0] == 0) then
                    (sum_m_and_divide, count_inc, reset_r) -> loop;
                else
                    (sum, reset_r) -> if_else;
    @if_else    if (r_reg[0] == 0) then
			        (equal_to_zero, count_inc, reset_r) -> loop;
		        else 
			        (not_equal_to_zero, count_inc, reset_r) -> loop;
    @stop       (stop) -> stop;
}

dp montgomery_test (out a, b, m : ns(1024))
{
	sfg do_always
	{
		a = 141961922344227189923304044674466259216849139914571548463026685087456952073320283567353956436423691990006925279380409798444651995839360240803449976730763257878317164187950501766146018885608500549779996329875392964006867908865978811384600885619746888819556246510538669443482377154725376450443917379508305690623;
        b = 133518921130163465724205375951027205152103919058163320355598750951451352240749495037977692115299036696058564623670986183083024835167240855070109586884091070677963209257239430806972445203584052409064878299165618106683887102259851685408345098495204698467282990235628752524312936897024077914680768091532759894753;
		m = 142469473898573440356695276830095297341807723798001973684650488988606433829875435617090912536801954429674763845008067112267225020649562301765838181046652327258434431800384431322324447530542188341951078054433098069407786590339704377060979874894104096248591825085111588666323520997935225535355645048944347862483;
    }
}

hardwired montgomery_hw (montgomery_test) { do_always; }

ipblock my8051 {
   iptype "i8051system";
   ipparm "exec=montgomery.ihx";
   ipparm "verbose=1";
}
 
ipblock my8051_instruction(out data : ns(8)) {
   iptype "i8051systemsource";
   ipparm "core=my8051";
   ipparm "port=P0";
}

ipblock my8051_variable(out data : ns(8)) {
   iptype "i8051systemsource";
   ipparm "core=my8051";
   ipparm "port=P1";
}

ipblock my_ram(in idata : ns(8); out odata : ns(1024); in address : ns(8); in wr : ns(1)) {
	iptype "i8051buffer";
	ipparm "core=my8051";
	ipparm "xbus=0x4000";
	ipparm "xrange=0x80";
}

dp montgomery_sys
{
	sig a : ns(1024);
	sig b : ns(1024);
	sig m : ns(1024);
    sig r : ns(1027);
	
	use montgomery_test(a, b, m);
	use montgomery_dp(a, b, m, r);
}

system S
{
	montgomery_sys;
}

