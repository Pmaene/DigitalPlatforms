/**
 * Adder
 */

dp adder_dp (in subtract : ns(1); in a, b : ns(1026); out s: ns(1027)) {
    sig b_eff : ns(1026);

    always {
        b_eff = subtract == 1 ? (~b + 1) : b;
        s = a + b_eff;
    }
}

/**
 * Main
 */

dp main_dp(in instruction, address, data_in : ns(8); out full_address : ns(16); out data_out, status: ns(8); out data_wr : ns(1)) {
    reg displayed_reg, mont_test_gte_reg : ns(1);
    reg counter_reg : ns(11);
    reg instruction_reg, address_reg, data_in_reg : ns(8);

    reg a_reg, b_reg, m_reg : ns(1024);
    reg r_reg : ns(1027);

    sig x_sig, y_sig : ns(1026);
    sig s_sig : ns(1027);
    sig subtract_sig : ns(1);

    use adder_dp(subtract_sig, x_sig, y_sig, s_sig);

    /**
     * Decoder
     */

    sfg decode {
        instruction_reg = instruction;
        address_reg = address;
        data_in_reg = data_in;
    }

    sfg no_adder {
        x_sig = 0;
        y_sig = 0;
        subtract_sig = 0;
    }

    sfg no_write {
        data_out = 0;
        data_wr = 0;
    }

    sfg no_address {
        full_address = 0;
    }

    sfg read_a_mem {
        full_address = (address_reg << 8)+(0x7F-counter_reg);
        a_reg = a_reg << 8 | data_in;
        counter_reg = counter_reg+1;
    }

    sfg read_a_reg {
        a_reg = r_reg;
    }

    sfg reset_a {
        a_reg = 0;
    }

    sfg read_b_mem {
        full_address = (address_reg << 8)+(0x7F-counter_reg);
        b_reg = b_reg << 8 | data_in;
        counter_reg = counter_reg+1;
    }

    sfg read_b_reg {
        b_reg = r_reg;
    }

    sfg reset_b {
        b_reg = 0;
    }

    sfg read_m {
        full_address = (address_reg << 8)+(0x7F-counter_reg);
        m_reg = m_reg << 8 | data_in;
        counter_reg = counter_reg+1;
    }

    sfg reset_m {
        m_reg = 0;
    }

    sfg read_result {
        full_address = (address_reg << 8)+(0x7F-counter_reg);
        r_reg = r_reg << 8 | data_in;
        counter_reg = counter_reg+1;
    }

    sfg write_result {
        full_address = (address_reg << 8)+counter_reg;
        data_out = r_reg >> (8*counter_reg);
        data_wr = 1;
        counter_reg = counter_reg+1;
    }

    sfg reset_r {
        r_reg = 0;
    }

    sfg add {
        x_sig = a_reg;
        y_sig = b_reg;
        subtract_sig = 0;
        r_reg = s_sig;
    }

    sfg subtract {
        x_sig = a_reg;
        y_sig = b_reg;
        subtract_sig = 1;
        r_reg = s_sig;
    }

    sfg reset_counter {
        counter_reg = 0;
    }

    sfg reset_displayed {
        displayed_reg = 0;
    }

    sfg mont_not_done {
        status = 2;
    }

    sfg idling {
        status = 1;
    }

    sfg not_idling {
        status = 0;
    }

    sfg display_cycles {
        displayed_reg = 1;
        $display("Cycles: ", $cycle);
    }

    sfg display_result {
        displayed_reg = 1;
        $display("Result: ", r_reg);
    }

    /**
     * Montgomery
     */

    sfg mont_counter_increment {
        counter_reg = counter_reg + 1;
        a_reg = a_reg >> 1;
    }

    sfg mont_sum {
        x_sig = r_reg;
        y_sig = a_reg[0] == 0 ? 0 : b_reg;
        subtract_sig = 0;
        r_reg = s_sig;
    }

    sfg mont_just_divide {
        r_reg = r_reg >> 1;
    }

    sfg mont_sum_and_divide {
        x_sig = r_reg;
        y_sig = b_reg;
        subtract_sig = 0;
        r_reg = s_sig >> 1;
    }

    sfg mont_sum_m_and_divide {
        x_sig = r_reg;
        y_sig = m_reg;
        subtract_sig = 0;
        r_reg = s_sig >> 1;
    }

    sfg mont_equal_to_zero {
        r_reg = r_reg >> 1;
    }

    sfg mont_not_equal_to_zero {
        x_sig = r_reg;
        y_sig = m_reg;
        subtract_sig = 0;
        r_reg = s_sig >> 1;
    }

    sfg mont_test_result {
        mont_test_gte_reg = r_reg >= m_reg ? 1 : 0;
    }

    sfg mont_test_gte {
        x_sig = r_reg;
        y_sig = m_reg;
        subtract_sig = 1;
        r_reg = s_sig;
    }

    sfg mont_test_lt {
        x_sig = r_reg;
        y_sig = 0;
        subtract_sig = 1;
        r_reg = s_sig;
    }
}

fsm main(main_dp) {
    initial init;
    state do, read_modulus, read_a_mem, read_b_mem, read_result, read_done, mont_do, mont_if_else, mont_test, write_result, write_done;

    @init           (no_adder, not_idling, no_write, no_address, decode) -> do;
    @do             if (instruction_reg == 0) then
                        (reset_displayed, idling, no_adder, no_write, no_address, decode) -> do;
                    else if (instruction_reg == 1 & displayed_reg == 0) then
                        (display_cycles, no_adder, not_idling, no_write, no_address, decode) -> do;
                    else if (instruction_reg == 2 & displayed_reg == 0) then
                        (display_result, no_adder, not_idling, no_write, no_address, decode) -> do;

                    else if (instruction_reg == 16) then
                        (reset_m, reset_counter, no_adder, not_idling, no_write, no_address, decode) -> read_modulus;
                    else if (instruction_reg == 17) then
                        (reset_a, reset_counter, no_adder, not_idling, no_write, no_address, decode) -> read_a_mem;
                    else if (instruction_reg == 18) then
                        (read_a_reg, no_adder, not_idling, no_write, no_address, decode) -> do;
                    else if (instruction_reg == 19) then
                        (reset_b, reset_counter, no_adder, not_idling, no_write, no_address, decode) -> read_b_mem;
                    else if (instruction_reg == 20) then
                        (read_b_reg, no_adder, not_idling, no_write, no_address, decode) -> do;
                    else if (instruction_reg == 21) then
                        (reset_r, reset_counter, no_adder, not_idling, no_write, no_address, decode) -> read_result;
                    else if (instruction_reg == 22) then
                        (reset_counter, no_adder, not_idling, no_write, no_address, decode) -> write_result;

                    else if (instruction_reg == 32) then
                        (reset_counter, reset_r, no_adder, mont_not_done, no_write, no_address, decode) -> mont_do;

                    else if (instruction_reg == 48) then
                        (add, not_idling, no_write, no_address, decode) -> do;
                    else if (instruction_reg == 49) then
                        (subtract, not_idling, no_write, no_address, decode) -> do;

                    else
                        (no_adder, not_idling, no_write, no_address, decode) -> do;
    @read_modulus   if (counter_reg < 0x80) then
                        (read_m, no_adder, not_idling, no_write, decode) -> read_modulus;
                    else
                        (idling, no_adder, no_write, no_address, decode) -> read_done;
    @read_a_mem     if (counter_reg < 0x80) then
                        (read_a_mem, no_adder, not_idling, no_write, decode) -> read_a_mem;
                    else
                        (idling, no_adder, no_write, no_address, decode) -> read_done;
    @read_b_mem     if (counter_reg < 0x80) then
                        (read_b_mem, no_adder, not_idling, no_write, decode) -> read_b_mem;
                    else
                        (idling, no_adder, no_write, no_address, decode) -> read_done;
    @read_result    if (counter_reg < 0x80) then
                        (read_result, no_adder, not_idling, no_write, decode) -> read_result;
                    else
                        (idling, no_adder, no_write, no_address, decode) -> read_done;
    @read_done      if (instruction_reg == 0x0F) then
                        (no_adder, not_idling, no_write, no_address, decode) -> do;
                    else
                        (idling, no_adder, no_write, no_address, decode) -> read_done;
    @mont_do        if (counter_reg >= 1024) then
                        (mont_test_result, no_adder, mont_not_done, no_write, no_address, decode) -> mont_test;
                    else if (r_reg[0] == 0 & a_reg[0] == 0) then
                        (mont_just_divide, mont_counter_increment, no_adder, mont_not_done, no_write, no_address, decode) -> mont_do;
                    else if (r_reg[0] == 0 & a_reg[0] == 1 & b_reg[0] == 0) then
                        (mont_sum_and_divide, mont_counter_increment, mont_not_done, no_write, no_address, decode) -> mont_do;
                    else if (r_reg[0] == 1 & a_reg[0] == 1 & b_reg[0] == 1) then
                        (mont_sum_and_divide, mont_counter_increment, mont_not_done, no_write, no_address, decode) -> mont_do;
                    else if (r_reg[0] == 1 & a_reg[0] == 0) then
                        (mont_sum_m_and_divide, mont_counter_increment, mont_not_done, no_write, no_address, decode) -> mont_do;
                    else
                        (mont_sum, mont_not_done, no_write, no_address, decode) -> mont_if_else;
    @mont_if_else   if (r_reg[0] == 0) then
                        (mont_equal_to_zero, mont_counter_increment, no_adder, mont_not_done, no_write, no_address, decode) -> mont_do;
                    else
                        (mont_not_equal_to_zero, mont_counter_increment, mont_not_done, no_write, no_address, decode) -> mont_do;
    @mont_test      if (mont_test_gte_reg == 1) then
                        (mont_test_gte, idling, no_write, no_address, decode) -> do;
                    else
                        (mont_test_lt, idling, no_write, no_address, decode) -> do;
    @write_result   if (counter_reg < 0x80) then
                        (write_result, no_adder, not_idling, decode) -> write_result;
                    else
                        (no_adder, no_write, no_address, not_idling, decode) -> write_done;
    @write_done     if (instruction_reg == 0x0F) then
                        (no_adder, no_write, no_address, not_idling, decode) -> do;
                    else
                        (idling, no_adder, no_write, no_address, decode) -> write_done;
}

ipblock my8051 {
    iptype "i8051system";
    ipparm "exec=main.ihx";
    ipparm "verbose=1";
}

ipblock my8051_instruction(out data : ns(8)) {
    iptype "i8051systemsource";
    ipparm "core=my8051";
    ipparm "port=P0";
}

ipblock my8051_address(out data : ns(8)) {
    iptype "i8051systemsource";
    ipparm "core=my8051";
    ipparm "port=P1";
}

ipblock my8051_status(in data : ns(8)) {
    iptype "i8051systemsink";
    ipparm "core=my8051";
    ipparm "port=P2";
}

ipblock my8051_memory(in idata : ns(8); out odata : ns(8); in address : ns(16); in wr : ns(1)) {
    iptype "i8051buffer";
    ipparm "core=my8051";
    ipparm "xbus=0x0000";
    ipparm "xrange=0xFFFF";
}

dp main_sys
{
    sig status, data_in, data_out, result_in, result_out : ns(8);
    sig instruction, address : ns(8);
    sig full_address : ns(16);
    sig data_wr : ns(1);

    use my8051;
    use my8051_instruction(instruction);
    use my8051_address(address);
    use my8051_status(status);
    use my8051_memory(data_in, data_out, full_address, data_wr);

    use main_dp(instruction, address, data_out, full_address, data_in, status, data_wr);
}

system S
{
    main_sys;
}
